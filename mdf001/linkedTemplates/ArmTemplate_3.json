{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "mdf001"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/MergeJoin')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "POH",
								"type": "DatasetReference"
							},
							"name": "POH"
						},
						{
							"dataset": {
								"referenceName": "POD",
								"type": "DatasetReference"
							},
							"name": "POD"
						},
						{
							"dataset": {
								"referenceName": "Product",
								"type": "DatasetReference"
							},
							"name": "Product"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "PurchaseOrderFact"
						}
					],
					"transformations": [
						{
							"name": "PurchaseOrderID"
						},
						{
							"name": "POHPOD"
						},
						{
							"name": "ProductID"
						},
						{
							"name": "ProductSelect"
						}
					],
					"script": "source(output(\n\t\tPurchaseOrderID as integer,\n\t\tRevisionNumber as integer,\n\t\tStatus as integer,\n\t\tEmployeeID as integer,\n\t\tVendorID as integer,\n\t\tShipMethodID as integer,\n\t\tOrderDate as timestamp,\n\t\tShipDate as timestamp,\n\t\tSubTotal as decimal(19,4),\n\t\tTaxAmt as decimal(19,4),\n\t\tFreight as decimal(19,4),\n\t\tTotalDue as decimal(19,4),\n\t\tModifiedDate as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> POH\nsource(output(\n\t\tPurchaseOrderID as integer,\n\t\tModifiedDate as timestamp,\n\t\tPurchaseOrderDetailID as integer,\n\t\tDueDate as timestamp,\n\t\tOrderQty as integer,\n\t\tProductID as integer,\n\t\tUnitPrice as decimal(19,4),\n\t\tLineTotal as decimal(19,4),\n\t\tReceivedQty as decimal(8,2),\n\t\tRejectedQty as decimal(8,2),\n\t\tStockedQty as decimal(9,2)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> POD\nsource(output(\n\t\tModifiedDate as timestamp,\n\t\tProductID as integer,\n\t\tName as string,\n\t\tProductNumber as string,\n\t\tMakeFlag as boolean,\n\t\tFinishedGoodsFlag as boolean,\n\t\tColor as string,\n\t\tSafetyStockLevel as integer,\n\t\tReorderPoint as integer,\n\t\tStandardCost as decimal(19,4),\n\t\tListPrice as decimal(19,4),\n\t\tSize as string,\n\t\tSizeUnitMeasureCode as string,\n\t\tWeightUnitMeasureCode as string,\n\t\tWeight as decimal(8,2),\n\t\tDaysToManufacture as integer,\n\t\tProductLine as string,\n\t\tClass as string,\n\t\tStyle as string,\n\t\tProductSubcategoryID as integer,\n\t\tProductModelID as integer,\n\t\tSellStartDate as timestamp,\n\t\tSellEndDate as timestamp,\n\t\tDiscontinuedDate as timestamp,\n\t\trowguid as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> Product\nPOH, POD join(POH@PurchaseOrderID == POD@PurchaseOrderID,\n\tjoinType:'inner',\n\tbroadcast: 'auto')~> PurchaseOrderID\nPurchaseOrderID select(mapColumn(\n\t\tPurchaseOrderID = POH@PurchaseOrderID,\n\t\tRevisionNumber,\n\t\tStatus,\n\t\tEmployeeID,\n\t\tVendorID,\n\t\tShipMethodID,\n\t\tOrderDate,\n\t\tShipDate,\n\t\tTaxAmt,\n\t\tFreight,\n\t\tModifiedDate = POH@ModifiedDate,\n\t\tPurchaseOrderID = POD@PurchaseOrderID,\n\t\tModifiedDate = POD@ModifiedDate,\n\t\tDueDate,\n\t\tOrderQty,\n\t\tProductID,\n\t\tUnitPrice,\n\t\tLineTotal,\n\t\tReceivedQty,\n\t\tRejectedQty,\n\t\tStockedQty\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> POHPOD\nPOHPOD, ProductSelect join(POHPOD@ProductID == ProductSelect@ProductID,\n\tjoinType:'inner',\n\tbroadcast: 'auto')~> ProductID\nProduct select(mapColumn(\n\t\tProductID,\n\t\tStandardCost\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> ProductSelect\nProductID sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> PurchaseOrderFact"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Pivot')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "PivotEmpCSV",
								"type": "DatasetReference"
							},
							"name": "PivotEmp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "Pivot"
						}
					],
					"script": "source(output(\n\t\tGender as string,\n\t\tSalary as integer '000',\n\t\tDept as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> PivotEmp\nPivotEmp pivot(groupBy(Gender),\n\tpivotBy(Dept),\n\t{} = sum(Salary),\n\tcolumnNaming: '$N$V_Salary',\n\tlateral: true) ~> Pivot\nPivot sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> sink1"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ProvinceNameChangeJOIN')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "HomicidesCanadaCSV",
								"type": "DatasetReference"
							},
							"name": "HomicidesCanadaCSV"
						},
						{
							"dataset": {
								"referenceName": "ProvinceCodesLkpCSV",
								"type": "DatasetReference"
							},
							"name": "ProvinceCodesLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ms01con1Bronze",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "JoinOnPrrovince"
						},
						{
							"name": "Select1"
						}
					],
					"script": "source(output(\n\t\tYear as string,\n\t\tCity as string,\n\t\tProvince as string,\n\t\tDGUID as string,\n\t\tHomicides as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> HomicidesCanadaCSV\nsource(output(\n\t\tProvince as string,\n\t\tCode as string,\n\t\t{Standard geographical classification (SGC) code} as string,\n\t\t{Region name} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ProvinceCodesLkp\nHomicidesCanadaCSV, ProvinceCodesLkp join(HomicidesCanadaCSV@Province == ProvinceCodesLkp@Province,\n\tjoinType:'inner',\n\tbroadcast: 'auto')~> JoinOnPrrovince\nJoinOnPrrovince select(mapColumn(\n\t\tYear,\n\t\tCity,\n\t\tDGUID,\n\t\tHomicides,\n\t\tProvinceCode = Code\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Select1\nSelect1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> sink1"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ProvinceNameChangeLKP')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "HomicidesCanadaCSV",
								"type": "DatasetReference"
							},
							"name": "HomicidesCanadaCSV"
						},
						{
							"dataset": {
								"referenceName": "ProvinceCodesLkpCSV",
								"type": "DatasetReference"
							},
							"name": "ProvinceCodesLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "Lookup1"
						},
						{
							"name": "Select1"
						}
					],
					"script": "source(output(\n\t\tYear as string,\n\t\tCity as string,\n\t\tProvince as string,\n\t\tDGUID as string,\n\t\tHomicides as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> HomicidesCanadaCSV\nsource(output(\n\t\tProvince as string,\n\t\tCode as string,\n\t\t{Standard geographical classification (SGC) code} as string,\n\t\t{Region name} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ProvinceCodesLkp\nHomicidesCanadaCSV, ProvinceCodesLkp lookup(HomicidesCanadaCSV@Province == ProvinceCodesLkp@Province,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup1\nLookup1 select(mapColumn(\n\t\tYear,\n\t\tCity,\n\t\tDGUID,\n\t\tHomicides,\n\t\tProvinceCode = Code\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Select1\nSelect1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> sink1"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SCD Type 2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "EmpSrcType2",
								"type": "DatasetReference"
							},
							"name": "EmpSrcType2"
						},
						{
							"dataset": {
								"referenceName": "EmpTarType2",
								"type": "DatasetReference"
							},
							"name": "EmpTarType2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "EmpTarType2",
								"type": "DatasetReference"
							},
							"name": "EmpTarInsert"
						},
						{
							"dataset": {
								"referenceName": "EmpTarType2",
								"type": "DatasetReference"
							},
							"name": "EmpTarUpdate"
						}
					],
					"transformations": [
						{
							"name": "SrcHashKey"
						},
						{
							"name": "TarHashKey"
						},
						{
							"name": "DoesNotExists"
						},
						{
							"name": "Exists"
						},
						{
							"name": "SetActive1"
						},
						{
							"name": "SetActive0"
						},
						{
							"name": "UpdateExisting"
						}
					],
					"script": "source(output(\n\t\tRef as integer,\n\t\tEmpID as integer,\n\t\tEmpName as string,\n\t\tDesignation as string,\n\t\tStartDate as date\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> EmpSrcType2\nsource(output(\n\t\tRef as integer,\n\t\tEmpID as integer,\n\t\tEmpName as string,\n\t\tDesignation as string,\n\t\tActive as integer,\n\t\tStartDate as date,\n\t\tEndDate as date\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> EmpTarType2\nEmpSrcType2 derive(SrcHashKey = md5(EmpName,Designation)) ~> SrcHashKey\nEmpTarType2 derive(TarHashKey = md5(EmpName,Designation)) ~> TarHashKey\nSrcHashKey, TarHashKey exists(SrcHashKey == TarHashKey,\n\tnegate:true,\n\tbroadcast: 'auto')~> DoesNotExists\nTarHashKey, SetActive1 exists(EmpTarType2@EmpID == EmpSrcType2@EmpID\n\t&& EmpTarType2@EmpName == EmpSrcType2@EmpName,\n\tnegate:false,\n\tbroadcast: 'auto')~> Exists\nDoesNotExists derive(Active = 1,\n\t\tEndDate = toDate('9999-12-31')) ~> SetActive1\nExists derive(Active = 0,\n\t\tEndDate = toDate(currentUTC())) ~> SetActive0\nSetActive0 alterRow(updateIf(true())) ~> UpdateExisting\nSetActive1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tRef as integer,\n\t\tEmpID as integer,\n\t\tEmpName as string,\n\t\tDesignation as string,\n\t\tActive as integer,\n\t\tStartDate as date,\n\t\tEndDate as date\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tRef,\n\t\tEmpID,\n\t\tEmpName,\n\t\tDesignation,\n\t\tActive,\n\t\tStartDate,\n\t\tEndDate\n\t)) ~> EmpTarInsert\nUpdateExisting sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tRef as integer,\n\t\tEmpID as integer,\n\t\tEmpName as string,\n\t\tDesignation as string,\n\t\tActive as integer,\n\t\tStartDate as date,\n\t\tEndDate as date\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['EmpID','EmpName','Designation'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tRef,\n\t\tEmpID,\n\t\tEmpName,\n\t\tDesignation,\n\t\tActive,\n\t\tStartDate,\n\t\tEndDate\n\t)) ~> EmpTarUpdate"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SCD Type1 Delete')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrdSrc",
								"type": "DatasetReference"
							},
							"name": "OrdSrc"
						},
						{
							"dataset": {
								"referenceName": "OrdTar",
								"type": "DatasetReference"
							},
							"name": "OrdTar"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "OrdTar",
								"type": "DatasetReference"
							},
							"name": "UpsertOrdTar"
						},
						{
							"dataset": {
								"referenceName": "OrdTar",
								"type": "DatasetReference"
							},
							"name": "DeleteFromOrdTar"
						}
					],
					"transformations": [
						{
							"name": "OrdTarLkp"
						},
						{
							"name": "SrcTarCompare"
						},
						{
							"name": "UpsertRecords"
						},
						{
							"name": "DsntExistInSrc"
						},
						{
							"name": "DeleteRecords"
						}
					],
					"script": "source(output(\n\t\tOrderID as integer,\n\t\tCustomerID as string,\n\t\tEmployeeID as integer,\n\t\tOrderDate as timestamp,\n\t\tOrdAmt as decimal(19,4)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> OrdSrc\nsource(output(\n\t\tOrderID as integer,\n\t\tCustomerID as string,\n\t\tEmployeeID as integer,\n\t\tOrderDate as timestamp,\n\t\tOrdAmt as decimal(19,4)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> OrdTar\nOrdTar select(mapColumn(\n\t\tOrderID_Lkp = OrderID,\n\t\tCustomerID_Lkp = CustomerID,\n\t\tEmployeeID_Lkp = EmployeeID,\n\t\tOrderDate_Lkp = OrderDate,\n\t\tOrdAmt_Lkp = OrdAmt\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> OrdTarLkp\nOrdSrc, OrdTarLkp lookup(OrderID == OrderID_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> SrcTarCompare\nSrcTarCompare alterRow(upsertIf(true())) ~> UpsertRecords\nOrdTar, OrdSrc lookup(OrdTar@OrderID == OrdSrc@OrderID,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> DsntExistInSrc\nDsntExistInSrc alterRow(deleteIf(isNull(OrdSrc@OrderID))) ~> DeleteRecords\nUpsertRecords sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tOrderID as integer,\n\t\tCustomerID as string,\n\t\tEmployeeID as integer,\n\t\tOrderDate as timestamp,\n\t\tOrdAmt as decimal(19,4)\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:true,\n\tkeys:['OrderID'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tOrderID,\n\t\tCustomerID,\n\t\tEmployeeID,\n\t\tOrderDate,\n\t\tOrdAmt\n\t)) ~> UpsertOrdTar\nDeleteRecords sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tOrderID as integer,\n\t\tCustomerID as string,\n\t\tEmployeeID as integer,\n\t\tOrderDate as timestamp,\n\t\tOrdAmt as decimal(19,4)\n\t),\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['OrderID'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> DeleteFromOrdTar"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SCD Type1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrdSrc",
								"type": "DatasetReference"
							},
							"name": "OrdSrc"
						},
						{
							"dataset": {
								"referenceName": "OrdTar",
								"type": "DatasetReference"
							},
							"name": "OrdTar"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "OrdTar",
								"type": "DatasetReference"
							},
							"name": "UpsertOrdTar"
						}
					],
					"transformations": [
						{
							"name": "OrdTarLkp"
						},
						{
							"name": "SrcTarCompare"
						},
						{
							"name": "UpsertRecords"
						}
					],
					"script": "source(output(\n\t\tOrderID as integer,\n\t\tCustomerID as string,\n\t\tEmployeeID as integer,\n\t\tOrderDate as timestamp,\n\t\tOrdAmt as decimal(19,4)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> OrdSrc\nsource(output(\n\t\tOrderID as integer,\n\t\tCustomerID as string,\n\t\tEmployeeID as integer,\n\t\tOrderDate as timestamp,\n\t\tOrdAmt as decimal(19,4)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> OrdTar\nOrdTar select(mapColumn(\n\t\tOrderID_Lkp = OrderID,\n\t\tCustomerID_Lkp = CustomerID,\n\t\tEmployeeID_Lkp = EmployeeID,\n\t\tOrderDate_Lkp = OrderDate,\n\t\tOrdAmt_Lkp = OrdAmt\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> OrdTarLkp\nOrdSrc, OrdTarLkp lookup(OrderID == OrderID_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> SrcTarCompare\nSrcTarCompare alterRow(upsertIf(true())) ~> UpsertRecords\nUpsertRecords sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tOrderID as integer,\n\t\tCustomerID as string,\n\t\tEmployeeID as integer,\n\t\tOrderDate as timestamp,\n\t\tOrdAmt as decimal(19,4)\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:true,\n\tkeys:['OrderID'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tOrderID,\n\t\tCustomerID,\n\t\tEmployeeID,\n\t\tOrderDate,\n\t\tOrdAmt\n\t)) ~> UpsertOrdTar"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/StringConcat')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "EmpInfoCsv",
								"type": "DatasetReference"
							},
							"name": "EmpInfoCSV"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaCon1",
								"type": "DatasetReference"
							},
							"name": "EmpInfoEmailCSV"
						}
					],
					"transformations": [
						{
							"name": "EmailCol"
						}
					],
					"script": "source(output(\n\t\tEmpID as string,\n\t\tEmpName as string,\n\t\tGender as string,\n\t\tSalary as string,\n\t\tDept as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> EmpInfoCSV\nEmpInfoCSV derive(Email = concat(EmpName,'@',Dept,'.com')) ~> EmailCol\nEmailCol sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tColumn_1 as string,\n\t\tColumn_2 as string,\n\t\tColumn_3 as string,\n\t\tColumn_4 as string,\n\t\tColumn_5 as string\n\t),\n\tpartitionFileNames:['EmpInfoEmail.csv'],\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> EmpInfoEmailCSV"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SurrogateKeys')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "EmpInfo1",
								"type": "DatasetReference"
							},
							"name": "EmpInfo1"
						},
						{
							"dataset": {
								"referenceName": "EmpInfo2",
								"type": "DatasetReference"
							},
							"name": "EmpInfo2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaCon1",
								"type": "DatasetReference"
							},
							"name": "EmpInfo"
						}
					],
					"transformations": [
						{
							"name": "EmpID"
						},
						{
							"name": "Union1"
						}
					],
					"script": "source(output(\n\t\tEmpID as short,\n\t\tEmpName as string,\n\t\tGender as string,\n\t\tSalary as short,\n\t\tDept as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> EmpInfo1\nsource(output(\n\t\tEmpName as string,\n\t\tGender as string,\n\t\tSalary as short,\n\t\tDept as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> EmpInfo2\nEmpInfo2 keyGenerate(output(EmpID as long),\n\tstartAt: 7L) ~> EmpID\nEmpInfo1, EmpID union(byName: true)~> Union1\nUnion1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tColumn_1 as string,\n\t\tColumn_2 as string,\n\t\tColumn_3 as string,\n\t\tColumn_4 as string,\n\t\tColumn_5 as string\n\t),\n\tpartitionFileNames:['EmpInfoUnion.csv'],\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> EmpInfo"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Top3PerDay')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SOD",
								"type": "DatasetReference"
							},
							"name": "SOD"
						},
						{
							"dataset": {
								"referenceName": "ProductDB02",
								"type": "DatasetReference"
							},
							"name": "Product"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "DailyProdSales"
						}
					],
					"transformations": [
						{
							"name": "Join1"
						},
						{
							"name": "SelectProd"
						},
						{
							"name": "Aggregate1"
						},
						{
							"name": "Window1"
						},
						{
							"name": "Filter1"
						}
					],
					"script": "source(output(\n\t\tSalesOrderID as integer,\n\t\tSalesOrderDetailID as integer,\n\t\tCarrierTrackingNumber as string,\n\t\tOrderQty as integer,\n\t\tProductID as integer,\n\t\tSpecialOfferID as integer,\n\t\tUnitPrice as decimal(19,4),\n\t\tUnitPriceDiscount as decimal(19,4),\n\t\tLineTotal as decimal(38,6),\n\t\trowguid as string,\n\t\tModifiedDate as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> SOD\nsource(output(\n\t\tProductID as integer,\n\t\tName as string,\n\t\tProductNumber as string,\n\t\tMakeFlag as boolean,\n\t\tFinishedGoodsFlag as boolean,\n\t\tColor as string,\n\t\tSafetyStockLevel as integer,\n\t\tReorderPoint as integer,\n\t\tStandardCost as decimal(19,4),\n\t\tListPrice as decimal(19,4),\n\t\tSize as string,\n\t\tSizeUnitMeasureCode as string,\n\t\tWeightUnitMeasureCode as string,\n\t\tWeight as decimal(8,2),\n\t\tDaysToManufacture as integer,\n\t\tProductLine as string,\n\t\tClass as string,\n\t\tStyle as string,\n\t\tProductSubcategoryID as integer,\n\t\tProductModelID as integer,\n\t\tSellStartDate as timestamp,\n\t\tSellEndDate as timestamp,\n\t\tDiscontinuedDate as timestamp,\n\t\trowguid as string,\n\t\tModifiedDate as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> Product\nSOD, SelectProd join(SOD@ProductID == SelectProd@ProductID,\n\tjoinType:'inner',\n\tbroadcast: 'auto')~> Join1\nProduct select(mapColumn(\n\t\tProductID,\n\t\tName,\n\t\tStandardCost\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectProd\nJoin1 aggregate(groupBy(ModifiedDate,\n\t\tName),\n\tProductCount = count(Name)) ~> Aggregate1\nAggregate1 window(over(ModifiedDate),\n\tdesc(ProductCount, true),\n\tProductSalesRank = rowNumber()) ~> Window1\nWindow1 filter(ProductSalesRank <= 3) ~> Filter1\nFilter1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> DailyProdSales"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TxtToDB')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LookupDIR",
								"type": "DatasetReference"
							},
							"name": "con1Lookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "DB01"
						}
					],
					"transformations": [],
					"script": "source(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> con1Lookup\ncon1Lookup sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> DB01"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/UnionBranch')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParaCon2Union",
								"type": "DatasetReference"
							},
							"name": "Group1"
						},
						{
							"dataset": {
								"referenceName": "ParaCon2Union",
								"type": "DatasetReference"
							},
							"name": "Group2"
						},
						{
							"dataset": {
								"referenceName": "ParaCon2Union",
								"type": "DatasetReference"
							},
							"name": "Group3"
						},
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "OrdersNorthwind"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "UnionDB"
						},
						{
							"dataset": {
								"referenceName": "ParaCon2",
								"type": "DatasetReference"
							},
							"name": "GroupUnion"
						}
					],
					"transformations": [
						{
							"name": "Union1"
						}
					],
					"script": "source(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinferDriftedColumnTypes: true,\n\tignoreNoFilesFound: false) ~> Group1\nsource(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinferDriftedColumnTypes: true,\n\tignoreNoFilesFound: false) ~> Group2\nsource(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinferDriftedColumnTypes: true,\n\tignoreNoFilesFound: false) ~> Group3\nsource(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> OrdersNorthwind\nGroup1, Group2, Group3, OrdersNorthwind union(byName: true)~> Union1\nUnion1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> UnionDB\nUnion1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tpartitionFileNames:['UnionGroup.csv'],\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> GroupUnion"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Unpivot')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "PivotEmp",
								"type": "DatasetReference"
							},
							"name": "PivotEmp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "UnpivotEmp"
						}
					],
					"transformations": [
						{
							"name": "Unpivot"
						},
						{
							"name": "DropRight7"
						}
					],
					"script": "source(output(\n\t\tGender as string,\n\t\tHR_Salary as long,\n\t\tIT_Salary as long,\n\t\tTraining_Salary as long\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PivotEmp\nPivotEmp unpivot(output(\n\t\tDepartment as string,\n\t\tSalary as long\n\t),\n\tungroupBy(Gender),\n\tlateral: true,\n\tignoreNullPivots: false) ~> Unpivot\nUnpivot derive(Department = dropRight(Department, 7)) ~> DropRight7\nDropRight7 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> UnpivotEmp"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/WindowsCumulativeAdd')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "EmpInfo",
								"type": "DatasetReference"
							},
							"name": "EmpInfoCsv"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "Partition"
						}
					],
					"transformations": [
						{
							"name": "Window1"
						}
					],
					"script": "source(output(\n\t\tEmpID as short,\n\t\tEmpName as string,\n\t\tGender as string,\n\t\tSalary as short,\n\t\tDept as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> EmpInfoCsv\nEmpInfoCsv window(asc(EmpID, true),\n\tRunningTotal = sum(Salary)) ~> Window1\nWindow1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> Partition"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/WindowsDensRank')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "EmpInfo",
								"type": "DatasetReference"
							},
							"name": "EmpInfoCsv"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "PartitionDensRank"
						},
						{
							"dataset": {
								"referenceName": "ParaDB01",
								"type": "DatasetReference"
							},
							"name": "Partition"
						}
					],
					"transformations": [
						{
							"name": "Window1"
						}
					],
					"script": "source(output(\n\t\tEmpID as string,\n\t\tEmpName as string,\n\t\tGender as string,\n\t\tSalary as string,\n\t\tDept as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> EmpInfoCsv\nEmpInfoCsv window(over(Dept),\n\tasc(Salary, true),\n\tSalRank = rank(),\n\t\tSalDensRank = denseRank()) ~> Window1\nWindow1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError') ~> PartitionDensRank\nWindow1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tEmpID,\n\t\tEmpName,\n\t\tGender,\n\t\tDept,\n\t\tSalary\n\t)) ~> Partition"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/logFile')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Temp",
								"type": "DatasetReference"
							},
							"name": "Temp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "OpLogFile",
								"type": "DatasetReference"
							},
							"name": "OpLogFile"
						}
					],
					"transformations": [
						{
							"name": "LogColumns"
						},
						{
							"name": "RemoveTemp"
						}
					],
					"script": "parameters{\n\tAdfName as string,\n\tPipelineName as string,\n\tTriggerName as string,\n\tRunID as string,\n\tTriggerID as string,\n\tTriggerTime as string,\n\tTriggerType as string,\n\tStatus as string,\n\tlogFilename as string\n}\nsource(output(\n\t\tColumn_1 as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> Temp\nTemp derive(AdfName = $AdfName,\n\t\tPipelineName = $PipelineName,\n\t\tTriggerName = $TriggerName,\n\t\tRunID = $RunID,\n\t\tTriggerID = $TriggerID,\n\t\tTriggerTime = $TriggerTime,\n\t\tTriggerType = $TriggerType,\n\t\tStatus = $Status) ~> LogColumns\nLogColumns select(mapColumn(\n\t\tAdfName,\n\t\tPipelineName,\n\t\tTriggerName,\n\t\tRunID,\n\t\tTriggerID,\n\t\tTriggerTime,\n\t\tTriggerType,\n\t\tStatus\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> RemoveTemp\nRemoveTemp sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tpartitionFileNames:[($logFilename)],\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> OpLogFile"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/logFileAppend')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Temp",
								"type": "DatasetReference"
							},
							"name": "Temp"
						},
						{
							"dataset": {
								"referenceName": "OpLogFileAsIp",
								"type": "DatasetReference"
							},
							"name": "TodaysLogFile"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "OpLogFile",
								"type": "DatasetReference"
							},
							"name": "OpLogFile"
						}
					],
					"transformations": [
						{
							"name": "LogColumns"
						},
						{
							"name": "RemoveTemp"
						},
						{
							"name": "Union1"
						}
					],
					"script": "parameters{\n\tAdfName as string,\n\tPipelineName as string,\n\tTriggerName as string,\n\tRunID as string,\n\tTriggerID as string,\n\tTriggerTime as string,\n\tTriggerType as string,\n\tStatus as string,\n\tlogFilename as string\n}\nsource(output(\n\t\tColumn_1 as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> Temp\nsource(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\twildcardPaths:[('LogFiles/Logs/' + $logFilename)]) ~> TodaysLogFile\nTemp derive(AdfName = $AdfName,\n\t\tPipelineName = $PipelineName,\n\t\tTriggerName = $TriggerName,\n\t\tRunID = $RunID,\n\t\tTriggerID = $TriggerID,\n\t\tTriggerTime = $TriggerTime,\n\t\tTriggerType = $TriggerType,\n\t\tStatus = $Status) ~> LogColumns\nLogColumns select(mapColumn(\n\t\tAdfName,\n\t\tPipelineName,\n\t\tTriggerName,\n\t\tRunID,\n\t\tTriggerID,\n\t\tTriggerTime,\n\t\tTriggerType,\n\t\tStatus\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> RemoveTemp\nRemoveTemp, TodaysLogFile union(byName: true)~> Union1\nUnion1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tpartitionFileNames:[($logFilename)],\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> OpLogFile"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/AggregateDerivedColumn')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "AggrDerivedColumns",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "AggrDerivedColumn",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"POH": {},
									"POFactAvg": {
										"tableName": "PurchasOrder_Fact_Avg"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Azure"
				},
				"annotations": [],
				"lastPublishTime": "2021-12-30T15:29:15Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ArrayToStringNoOP')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Concat Funtion with Loop",
				"activities": [
					{
						"name": "EmpInfoEmailCSV",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFileName": "EmpInfoEmail.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"dataset": {
								"referenceName": "ParaCon1",
								"type": "DatasetReference",
								"parameters": {
									"folderName": "Bronze"
								}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ForEachEmail",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "EmpInfoEmailCSV",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('EmpInfoEmailCSV').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Set tmpEmail",
									"type": "SetVariable",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"variableName": "tmpEmail",
										"value": {
											"value": "@concat(item().Email,',',variables('Email'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Email",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set tmpEmail",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"variableName": "Email",
										"value": {
											"value": "@variables('tmpEmail')",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "EmailString",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "ForEachEmail",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "EmailString",
								"type": "DataFlowReference",
								"parameters": {
									"StrOP": {
										"value": "'@{variables('Email')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"Temp": {},
									"EmpDataEmailSTRCsv": {
										"folderName": "Silver"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"Email": {
						"type": "String"
					},
					"tmpEmail": {
						"type": "String"
					}
				},
				"folder": {
					"name": "Real Life Scenarios"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ConcatColumn')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "1.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "StringConcat",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"EmpInfoCSV": {},
									"EmpInfoEmailCSV": {
										"folderName": "Bronze"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "Real Life Scenarios"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/StringConcat')]"
			]
		}
	]
}